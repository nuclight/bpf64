#include <bpf64helpers.bah>
#include "nuc_ts_incr.bah"

/* C preprocessor is used */

#define TCPOPT_TS_KIND 8  /* Timestamp option has Kind=8 */ 
#define TCPOPT_TS_LEN 10  /* and length 10, per RFC 1323 */

#define LOG bpf64_printf

/* helper macros to make printing less tedious */
#define LOG1(fmt, arg1)	printarg = arg1; LOG(fmt, printarg);
#define LOG2(fmt, arg1, arg2)		\
	printarg1 = arg1;		\
	printarg2 = arg2;		\
	LOG(fmt, printarg1, printarg2);

/* 'pragma' is 'use' */
use literal;	/* combine all C ""-strings in literal at start */
/* TODO actual syntax for creating segment from it */

/* update counters about our work, return 1 on success and 0 on fail */
func rec2stat(error)	/* one input register, R0 */
my value;		/* and one local register, R1 */
{
	A = 1;
	if error > STAT_MAX	/* it may be 'goto', but direct 'jt' and */
		jt fail jf ok;	/* 'jf' for short jumps are also allowed */
fail:
	A = 0;
	error = STAT_PROGER_ERROR;
ok:
	X = error;		/* offset can be only in index registers */
	value = DS:P[X:8];	/* get current counter value to local register */
	R1 += 1;		/* it's just alias, actual register will work */
	DS:P[X:dw] = value;	/* shared memory in DS segment */
	return A;
}

/*** Comments about higher-level logic with 3 '*'s */

/* parameters:
 * network header start offset - in, l4 header offset - out,
 * returns L4 protocol
 */
func parse_ipv4(nh_pos, l4_off)
my iphofs, data_end;
out error printarg;	/* no comma - aliases to same register */
{
	LOG1("parse_ipv4: nh_pos=%d\n", nh_pos);

	data_end = P.len; /* load length of packet */
	/* 
	 * Instead of dereferencing X manually as in rec2stat(), we can
	 * put syntax construction backed by local variable (register),
	 * which will assign X for us onevery use, so init just once.
	 */
	X = nh_pos;
	index iph use X sequence ip4hdr in iphofs;

	/*** Error-checking packet: length of fixed header */
	B = nh_pos;	/* save some stack by global register */
	B += sizeof ip4hdr; /* note it doesn't know about alignment */
	if B > data_end {
		LOG1("parse_ipv4: iphdr+20 past end=%d of pkt\n", data_end);
		/* Call may be done via prepared arguments (registers) */
		error = STAT_IPHDRSHORT;
		call rec2stat(); /* 'call' and args are optional */
		return 0;
	}

	/*** Error-checking packet: total length field */
	B = P[iph.tot_len];	/* tracked index here will do */
				/* X = iphofs; */
				/* B = P[X+2:2] */
	C = B;		/* leave B for printf */
	C += nh_pos;
	if C > data_end {
		LOG1("parse_ipv4: tot_len=%d\n", B);
		/* Note function call with args will generate assignments */
		/* to output registers, so you may simply write: */
		rec2stat(STAT_IPTOTSHORT);
		return 0;
	}

	/*** Error-checking packet: IHL field */
	B = iph.ihl; /* for fixed field inside struct P[] is unnecessary */
	if B < 5 {
		LOG1("parse_ipv4: ihl=%d\n", B);
		rec2stat(STAT_IPHDRSHORT);
		return 0;
	}

	B -= 5; B *= 4; B += 20;/* l4_off = 20 + 4*(iph->ihl - 5); */
	l4_off = B;
	LOG1("parse_ipv4: l4_off:=%d\n", l4_off);

	/*** Error-checking packet: IHL field & real length */
	B += nh_pos; /* if (*nh_pos + *l4_off > data_end) */
	if B > data_end {
		rec2stat(STAT_IPHDRSHORT);
		return 0;
	}
	
	/* return values are: Accumulator and l4_off in stack */
	A = iph.protocol;
	return A; 

}

/* parameters:
 * network header start offset - in, l4 header offset from L3 - out,
 * returns L4 protocol
 */
func parse_ipv6(nh_pos, l4_off)
my iphofs, data_end, next_hdr_type,
   l4_abs;	/* absolute l4_off - from start of packet */
out error printarg;	/* no comma - aliases to same register */
{
	data_end = P.len; /* load length of packet */

	X = nh_pos;
	index ip6h use X sequence ipv6hdr in iphofs; 

	/*** Error-checking packet: length of fixed header */
	B = nh_pos;	/* save some stack by global register */
	B += sizeof ipv6hdr; /* sizeof is compile-time constant */
	if B > data_end {
		rec2stat(STAT_IPHDRSHORT);
		return 0;
	}

	/*** Error-checking packet: total length field */
	B = ip6h.payload_len;
	if B > data_end {
		rec2stat(STAT_IPTOTSHORT);
		return 0;
	}

	/*** l4_off is from start of L3 header, not entire packet */
	l4_off = sizeof ipv6hdr;
	next_hdr_type = ip6h.nexthdr;

	/*
	 * Note that index:
	 * 1) may be X + constant (or Y + constant), i.e. for just one
	 *    header we could use:
	 *    index hdr use X + sizeof ipv6hdr sequence ipv6_opt_hdr;
	 * 2) may be declared without storage variable.
	 *    In this case it's somewhat like just textual substitution,
	 *    and programmer must control index register manually.
	 */
	index hdr use X sequence ipv6_opt_hdr;

	/* Max 6 iterations, 'asc' is synonym for 'ascending' */
	loop I = 0 asc to 5 {
		/* ALU in BPF64 allows up to 3 registers */
		l4_abs = nh_pos + l4_off;
		X = l4_abs;

		/*** Error-checking packet: is fixed header contained? */
		B = X;
		B += 8; /* not sizeof ipv6_opt_hdr, see RFC 2460 */
		if B > data_end {
			rec2stat(STAT_IP6EXTHDRSHORT);
			return 0;
		}

		/*
		 * Assembler has no switch/case, but it is still possible
		 * to organize code simple than bunch of if's - one of
		 * instructions is jump table, by lower either byte or halfword
		 * of specified register, as index to table of labels.
		 *
		 * In this particular example it is not most effective way:
		 * bpf64awc will create 135 halfword entries (IPPROTO_MH)
		 * mostly filled with offset to default branch. Still,
		 * to demonstrate...
		 */
		jumptable b in next_hdr_type {
			IPPROTO_HOPOPTS => dwords_len,
			IPPROTO_DSTOPTS => dwords_len,
			IPPROTO_ROUTING => dwords_len,
			IPPROTO_MH	=> dwords_len,
			IPPROTO_AH	=> words_len,
			IPPROTO_FRAGMENT=> one_frag,
			default		=> nonext,
		};
	dwords_len:
		B = hdr.hdrlen; B += 1; B *= 8;
		l4_off += B;  /* l4_off += (hdr->hdrlen + 1) * 8 */
		next_hdr_type = hdr.nexthdr;
		goto endswitch;
	words_len:
		B = hdr.hdrlen; B += 2; B *= 4;
		l4_off += B; /* l4_off += (hdr->hdrlen + 2) * 4; */
		next_hdr_type = hdr->nexthdr;
		break;
	one_frag:
		l4_off += 8;
		next_hdr_type = hdr->nexthdr;
		break;
	nonext:
		/* Found a header that is not an IPv6 extension header */
		LOG("parse_ipv6: l4_off:=%d next=%d\n", l4_off, next_hdr_type);
		A = next_hdr_type;
		return A;
	endswitch:
	}

	LOG2("parse_ipv6: l4_off:=%d next_hdr_type=%d\n", l4_off, next_hdr_type);
	A = next_hdr_type;
	return A;
}

/* TODO rewrite other nuc_ts_prog_kern.c code below this point */
